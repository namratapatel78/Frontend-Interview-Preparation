Facebook

RADIO - Requirements, High Level Architecture, Data model, Interface, Optimization/Performance

  1. REQUIREMENTS
    -> Clarify Functional and Non Functional (under the hood) Requirements
      Functional
        Must have
          - Post feed
          - Post support text, image (ask size of image) and videos - Image Optimization / Video Optimization
          - Infinite scroll - with virtualized list (react-window)
            - Use Intersection observer
            - Use Infinite Scroll Library
          - Add, delete or edit post
          - Like or comment on post
          - Basic user profiles
          - Active users ??
        Nice to have
          - Advanced privacy controls
          - Search functionality
      Non Functional
        - Performance - Fast load time (under 500ms per load)
        - Mobile support - responsive layouts
        - Offline access - Cache recent posts, support offline reads
        - Accessibility - Semantic elements, Keyboard navigation (Tab index or Tab Order), screen-reader support, color contrast, REM font, Aria labels
        - Internationalization (multi-language)
        - Security - Secure authentication, XSS prevention
        - Scalability - The system must scale to millions of users
        - Observability - Error logging, monitoring performance, tracking user journey
        - Data consistency - Real time updates vs eventual consistency
    -> Napkin math (Scale estimation) ??
    -> Clarify user roles and access patterns
      - Types of users - regular user, admin, guest
      - User actions - Reading posts, like post, comment on post, edit post
      - Authentication - Do they require authentication or they can view without it.
    -> Clarify data requirements
      - User data - Profile, preferences
      - Post data - Content, timestamp, media (stored separately in )
      - Media data - image/video stored separately (CDN or media storage)

  2. HIGH LEVEL ARCHITECTURE
    -> MVVM
      ğŸ§© MVVM in React
        React components often become overly complex â€” handling data fetching, state, side effects, and UI all in one place. This leads to poor maintainability and testability.

        To address this, the MVVM (Model-View-ViewModel) pattern helps separate concerns:

        Model: Handles data & business logic (e.g., API, Redux)
        ViewModel: Uses hooks/container components to manage state, side effects, and prepare data
        View: UI components that only render props (presentational)

                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚        Clients         â”‚
                    â”‚ (Browser, Mobile Web)  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                      HTTP(S) / API Calls
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚       React App        â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                        â”‚                        â”‚
        â–¼                        â–¼                        â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚    View       â”‚ uses â”‚  ViewModel     â”‚fetches/â”‚     Model        â”‚
 â”‚ (UI Component)â”‚----->â”‚ (Hooks /       â”‚------->â”‚ (API layer /     â”‚
 â”‚               â”‚      â”‚  Container Compâ”‚ updatesâ”‚  Business Logic) â”‚
 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜<-------â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                     uses                        fetches /
        â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  updates
        â”‚               â–¼              â–¼
        â”‚        Local State /    Side Effects
        â”‚       Derived Data     (useEffect, etc.)
        â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚      Component Library      â”‚ (e.g., ShadCN, MUI)
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    -> MVC
      Model: API/data layer or Redux store
      View: React components (UI)
      Controller: Event handlers or useEffect logic that mediates between view and model
    -> MVC mixes UI and logic, harder to maintain in React.
      MVVM (with hooks as ViewModel) promotes clean code, testability, and aligns better with React's design.


  3. DATA MODEL - Build out the data types to render content on the client with typescript
    -> useState, useContext, Redux, Recoil, Zustand, MobX
    -> useContext vs Redux
    -> Data persistence
      - Local Storage
      - Session Storage
      - Cookies
      - IndexedDB:
        Pro - Ample storage, supports complex objects, asynchronous
        Cons - API is more complex, browser quirks
    -> Scoped vs Global state
      Scoped
        - State used only in one component or a small subtree
        - Only the owning component and its children re-render when the state changes. Keeps updates local and efficient.
      Global
        - State is shared across multiple views or distant components
        - All components that consume the global state will re-render on any state change, which can impact performance if not managed carefully.
    -> Client Data Model: Refer https://frontendlead.com/system-design/client-only-data-management-frontend-design

  4. API

  API INTERFACE - Choose protocol for the API layer and explain why - https://frontendlead.com/system-design/interface-communication-frontend-system-design
    -> HTTP (Rest)
      - News feed (scrolling to load posts or pulling new content)
      - Profile/Settings management (fetching and updating user preferences)
      - Analytics dashboard (loading & filtering resports or metrics)
    -> Short polling - Client frequently requests new data on a timer ??
      - Client controls the timing.
      - Server responds immediately, even if there's no new data.
      - Requests are sent at fixed intervals (e.g., every 5 seconds).
      - Consumes more bandwidth and server resources.
      - Less efficient, especially when updates are rare.
      - Real-time experience is limited due to fixed delays.
      - Slower
    -> Long polling ??
      - Server controls the timing.
      - Server holds the request until new data is available or it times out.
      - Client sends the next request only after the previous one finishes.
      - Fewer requests overall, making it more efficient.
      - Better use of resources.
      - Provides a near real-time experience.
      - Slower
      - Easy to load balance ??
      - Firewall protection ??
    -> WebSockets - Full duplex persistent 2-way communication over 1 single TCP connection - Need deep research ??
      - Chat application (real time messaging b/w users)
      - Collaborative editing (multiple users editing the same document)
      - Fast
      - Expensive - Takes up lot of memory on server and client to keep the connection open
      - Need to create Firewalls and load balancing yourself ??
      - Not http2 friendly - no multiplexing ??
    -> Server Sent Events (SSE) - Server pushes data to client, client receives in real time (one way communication)
      - Live notifications (Instant alerts or status updates)
      - AI/Streaming response (Streaming generated text like ChatGPT)
    -> GraphQL - Pull the data we need
      - Profile/Settings management (fetching and updating user preferences)
      - Analytics dashboard (loading & filtering resports or metrics)
      - HTTP2 friendly
      - Type friendly
    -> Web rtc

    -> HTTP1 vs HTTP2 -> https://frontendlead.com/system-design/web-protocols-cheat-sheet - Create diagram in Excalidraw and save it
      - Supports multiplexing (no more request blocking) - allowing multiple requests and response to be sent asynchronously over a single TCP connection reducing latency and improves page load time.
      - Parallel requests
      - Request prioritization: Resources can be prioritized to load critical ones first. how ??
      - Server push: Server can send assets (like CSS/JS) without a client request. how ??
      - Header compression - less data sent per request - The dynamic table is a shared in-memory structure maintained separately by both client and server during a connection. It stores header name-value pairs that have been sent recently, so that future messages can refer to them by index instead of resending them.
        - Size-limited	The table has a maximum size (usually ~4KB by default, configurable).
        - Indexed headers	Headers get an index (like position in an array) as they're added.
        - Eviction	When it exceeds the max size, oldest entries are removed (FIFO).
        - Shared knowledge Client and server must stay in sync about what's in the table.
        - Secure per connection	Each client-server connection maintains its own dynamic table.


  API DESIGN
    -> Discuss what HTTP protocol you will use and why (HTTP 1 or 2)

    -> Design the API
      POST /login
      {
        "email": "user@example.com",
        "password": "123456"
      }
    -> Request type
      - GET - Fetches data
      - POST - Sends data
      - PUT/PATCH - Update data
      - DELETE - Remove data
    -> Authentication
      - Use JWT (JSON Web Tokens) or OAuth2 - Research more ??
      - Token sent in request headers: Authorization: Bearer <token>
      - Secure endpoints should validate the token.
    -> Request inputs
      - Query parameters (/users?page=2)
      - URL parameters (/user/:id)
      - Request body (for POST/PUT)
    -> Requests outputs (high level): Describe what the server will return
      - Data structure (JSON)
      - Error messages
      - Pagination (if list)
    -> Mention status codes: Use standard HTTP status codes
      - 200 OK â€“ success
      - 201 Created â€“ resource created
      - 400 Bad Request â€“ validation errors
      - 401 Unauthorized â€“ auth failed
      - 404 Not Found â€“ resource missing
      - 500 Internal Server Error â€“ server crash
    -> Expected response
      - Always return consistent structure
      - Include status, message, and data
      - Error responses should have meaningful messages
      - Example:
        // success
        {
          "status": "success",
          "data": { ... }
        }
        // error
        {
          "status": "error",
          "message": "User not found"
        }

      -> API Design Best Practices
        - Version your API: Use /api/v1/... to support future changes safely.
        - Consistent naming: Stick to a clear naming style (camelCase or snake_case).
        - Secure authentication: Use tokens/headers, avoid sensitive data in URLs.
        - Correct status codes: Return appropriate HTTP status (200, 400, 401, etc).
        - Clear error messages: Include error code and message for better debugging.
        - Filtering & sorting: Allow clients to control data needs efficiently.
        - Avoid over-fetching: Use GraphQL or well-designed REST to fetch only needed fields.
        - Documentation: Keep API specs updated for smooth frontend-backend collaboration.

      -> Common Request Headers
        GET /api/v1/gql/feed
        - Authorization: Bearer eyJhbGci0i... -  used for authenticating the user session.
        - Content-Type: application/json - specifies the format of the request body.
        - X-User-ID: user_12345 - User identifier for tracking or personalization
        - Accept-Language: en-US - Sets the preferred language for localized responses.
        - X-Request-ID: 123e4567-e89b-12d3-a456-426614174000 - Optional, used for tracing and debugging across distributed systems or microcervices.

  5. OPTIMIZATIONS / PERFORMANCE
   -> Types of Front-End Performance Bottlenecks
    - Network bottlenecks: Large payloads, slow APIs, or too many requests.
      Solution
        - Use HTTP/2
        - Compression Headers: By sending compression headers, server to respond with compressed data
          - gzip (supported in 100% browsers, fast)
          - brotli (supported in 95% modern browsers, slow, better compression)

          Client header -> Accept-Encoding: gzip, br
          Server response -> 1. Content-Encoding: br    2. Vary: Accept-Encoding
        - Caching
          - Browser Cache (HTTP cache) - Caches all kinds of resources and API response
            If a cached resource has not expired, the browser will serve it directly from its local cache without making a network request to the server for that resource.

            1. Client/browser requests static resource (css. html, images, js)
              GET /logo.png HTTP/1.1
              Host: example.com
              Server/CDN responds with cache headers
            2. Server responds with:
              Cache-Control: max-age=86400, public -> means cache for 1 day and public allows any cache (e.g. browser, CDN) to store it.
              ETag: 'xyz-123' - Validator header HTTP uses for conditional requests.
            3. Browser caches logo.png for 86400 seconds (1 day). Remembers the ETag ("xyz-123").
            4. Client/browser requests static resource (css. html, images, js)
              GET /logo.png HTTP/1.1
              Host: example.com
              If-None-Match: "xyz-123"
            5. Server checks if the resource's ETag is unchanged. If unchanged, responds:
            HTTP/1.1 304 Not Modified
            Cache-Control: max-age=600
            6. Browser uses its cached copy. Updates expiry time as instructed by server.
          - Through CDN (AWS, Cloudflare): Clientâ€“CDNâ€“OriginServer
            A Content Delivery Network (CDN) is a system of geographically distributed servers (Edge Servers or Points of Presence/PoPs) designed to deliver web contentâ€”such as images, videos, JavaScript, CSS, and even dynamic dataâ€”efficiently and reliably to users worldwide

            Basic Flow:
            User Request: A browser requests a resource (e.g., an image or a webpage).
            DNS Lookup: The DNS points the user to a nearby CDN edge server rather than the origin server.
            Cache Hit/Miss:
              - If the edge server has a cached copy (â€œcache hitâ€), it delivers the resource instantly.
              - If not (â€œcache missâ€), the edge server fetches it from the origin, caches it, and serves it to the user.
            Subsequent Requests: Future requests for that asset from other users in the same region are served directly from the cache.

            Key Components of a CDN
            Component	Description
            Origin Server: Stores and maintains the authoritative copy of all content.
            Edge Servers / PoPs: Geographically distributed servers that cache and serve content to users nearby.
            DNS Servers: Direct user requests to the optimal edge server based on location and network health.
          - Service Worker (Client-Controlled Offline Cache):

            Caches all kinds of resources and API response

            A service worker is a background JavaScript process that gives you fine-grained control over how your app interacts with the network and caches, enabling key features for progressive web applications, including offline access, speedy resource retrieval, and background capabilities.

            The cache data used by service workers is stored in the browser's Cache Storage, which is a specific, sandboxed storage accessible to service workers. This Cache Storage is separate from other storage mechanisms like localStorage or IndexedDB, though IndexedDB can also be used by service workers if needed.

            Cached files persist beyond page reloads until explicitly deleted or invalidated by the app or user.

            The service worker starts and stops automatically as needed, conserving resources.
            Service workers are also terminated when not in use and will be restarted by the browser when a relevant event occurs

            - Offline experiences and full offline web apps
            - Faster loading through aggressive client-side caching
            - Push notifications for re-engagement
            - Background sync (like submitting forms once the user is back online)
            - Advanced asset and API caching strategies.
            - Works with HTTPS or local environment - Ensures all communications are secure


            Scenario
              Progressive Web App with a service worker installed.
              User visits app. Service Worker intercepts network requests.
              Service Worker logic:
                Checks CacheStorage (custom, managed JS cache).
                Could instantly return cached shell/resources, even offline.
                Also can fetch from network in background to update cache for next visit.
          - Key Takeaways:
            Browser, CDN, and service worker caches all use HTTP headers and request-response patterns to decide when/how assets are reused.

            ETag, Cache-Control, and Expires headers dictate cache freshness, validation, and updating.

            Conditional requests minimize bandwidthâ€”browser often gets data â€œfor freeâ€ from disk or nearby CDN edge.

            Service workers add another programmable layer for next-level control and offline support.
          - Apollo Client for GraphQL data ?? - Learn
        - Batch request
        - Image Optimizations
        - Bundle Splitting / Lazy loading
        - Compress all static resources
          - Use Webpack Compression Plugins During Build
    - Rendering bottlenecks: Too much DOM, inefficient updates, or unoptimized rendering cycles. Rendering is where users differentiate between a slow and a fast app. If your UI lags, jumps around, or doesn't load content in the correct order, people notice immediately

    - JavaScript execution: Heavy libraries, unnecessary code, or blocking scripts.
      - Delegate some work like Calculations to web worker - This will not block the JS thread
    - Asset delivery: Large images, fonts, or video assets that slow down page loads.
    - Device constraints: Slow CPUs, low memory, or poor graphics on specific user devices.
   -> How to Measure Performance in a React App
    1. Local Measurement (Dev Environment)
      Use tools like:
      - Google PageSpeed Insights
      - Chrome DevTools
      - Lighthouse
      - React Profiler / Redux DevTools
      - Helps identify:
      - Slow components
      - Rendering bottlenecks
      - JS execution time
    2. User-Centric (Real-World) Measurement
      Track performance from actual users to get accurate insights.
      Key metrics to measure:
      - TTI (Time to Interactive): When page becomes usable
      - FCP (First Contentful Paint): When first visible content appears
      - FPS (Frames Per Second): Smoothness of animations and scrolling
      - LCP (Largest Contentful Paint): Time to render largest visible content
      - CLS (Cumulative Layout Shift): Visual stability
    3. Send Metrics to Monitoring Tools - GA, Amplitude
    4. Key Takeaway
      - Don't optimize blindly.
      - Always measure first, find bottlenecks, then optimize based on real user data.

  6. Accessibility
    -> Keyboard navigation - Enables navigation without a mouse; essential for motor-impaired and screen reader users
    -> Screen reader support - aria attributes - Provides semantic info for assistive technologies to convey UI structure and state
    -> Color constrast - Ensures text and UI elements are distinguishable by users with visual impairments
    -> REM fonts - Allows font size scaling respecting user preferences for better readability
    -> HTML semantics element


  7. Security: https://frontendlead.com/system-design/frontend-security-best-practices-for-web-applications
    -> Authentication
    -> Authorization
    -> XSS - Cross Site Scripting attack - injects malicious script
      - React comes with sanitization or you can use DOMPurify API to sanitize HTML
      - Use correct Content Security Policy Headers so that we are requesting data and it's coming from trusted source
      - Input validation and sanitization
    -> CORS - Ensure correct Cross Origin Resource Sharing policy to make sure that the data which we are receiving is from the trusted source
    -> HTTPS - Secure and Performant
    -> Cross Site Request Forgery (CSRF) Protection - CSRF tokens and Same-Site Cookies
    -> Session management
    -> Dependency scanning


--------------------------------------

Extra points:

1. Testing
  - Unit test using jest for logic-heavy utilities
  - Integration tests for UI interactions
  - End to end test using cypress




--------------------------------------------------------------------------------

What are Container Components in React?
Container components (also called smart components) are responsible for:
  Handling data fetching
  Managing state and side effects
  Passing data to presentational (dumb) components
They do not render much UI themselves â€” instead, they act as a bridge between logic (ViewModel) and the UI (View).


// UserListContainer.tsx - Container component
import React, { useEffect, useState } from "react";
import { fetchUsers } from "./api";
import UserList from "./UserList";

const UserListContainer = () => {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetchUsers().then(setUsers);
  }, []);

  return <UserList users={users} />;
};

export default UserListContainer;

// UserList.tsx - Presentation component
const UserList = ({ users }) => (
  <ul>
    {users.map(user => <li key={user.id}>{user.name}</li>)}
  </ul>
);

export default UserList;

--------------------------------------------------------------------------------

ğŸ” Impact of Doubling Users in a Web App
âœ… 1. Frontend (React App)
Minimal direct impact: React apps are served as static files (JS, CSS, HTML), typically via CDNs.

Impacts may include:
Increased load time if CDN or hosting has bandwidth limits.
More API requests per second sent to backend.
Potential rate-limiting or blocked requests if APIs can't handle the surge.

âœ… 2. Backend/API Layer
Direct impact: More users = more requests = more server load.

Consequences:
Increased CPU and memory usage
Slower response times
Higher latency or timeouts
Database contention or increased read/write loads
Need for scaling APIs horizontally (load balancing, more server instances)

âœ… 3. Database
More concurrent read/write operations.

Could hit:
Connection limits
Query performance degradation
Locking issues if not optimized

âœ… 4. Infrastructure (Server, CDN, Load Balancer)
More bandwidth and storage usage

Potential cost increase on:
Hosting
CDN egress traffic
Database storage & throughput

May require:
Autoscaling policies
Caching strategy improvements
Enhanced monitoring and alerts

ğŸ“ˆ Example: If 3000 users generate 30,000 API calls/day
Doubling users = 6000 â†’ 60,000 API calls/day

If your backend supports 100 RPS (requests per second), and this load peaks simultaneously, you could exceed capacity, leading to:
Dropped or throttled requests
Downtime
Poor user experience

ğŸ’¡ What You Should Do as a Frontend Developer
Use caching (localStorage, SWR, React Query) to minimize API hits.
Implement pagination, infinite scroll, lazy loading to reduce payload size.
Avoid unnecessary re-renders to improve performance.
Use CDNs and image optimizations.

--------------------------------------


When designing the architecture for a front-end application, there are several additional considerations to keep in mind:

Performance: Ensure that the application is responsive and performs well under various conditions. This can involve optimizing the Ul rendering, minimizing the number of network requests, and reducing the size of the data being transferred. Techniques such as lazy loading, caching, and debouncing can help improve the application's performance.

Scalability: Design the application to handle increasing users and data. This can involve using techniques such as pagination, infinite scrolling, and virtualized lists to manage large amounts of data. It can also include designing the architecture to support horizontal scaling, such as using load balancers and distributed data stores.

Maintainability: Ensure that the application is easy to maintain and extend. This can involve using modular components, following coding standards, and writing tests. It can also include managing the codebase using tools such as linters, code formatters, and version control systems.

Security: Protect the application from security threats like cross-site scripting (XSS), cross-site request forgery (CSRF), and SQL injection. This can involve using techniques such as input validation, output encoding, and secure communication protocols. It can also include the following best practices for authentication and authorization, such as using OAuth and JWT.

User Experience: Design the application to provide a positive user experience. This can involve using techniques such as responsive design, accessibility, and internationalization. It can also include the following best UI design practices: consistent layouts, straightforward navigation, and intuitive interactions.

--------------------------------------

Virtualization

Virtualization in React is a technique that optimizes rendering performance for large datasets by only rendering the components that are currently visible in the viewport, plus a small buffer around them, instead of rendering every item in a long list or grid. This significantly improves performance, memory usage, and user experience by keeping the number of DOM nodes low, even when the underlying data is massive.

Dynamic Rendering: Only items in the visible range (plus a small buffer for smooth scrolling) are rendered. As the user scrolls, the window shifts and the rendered items change accordingly


-----------------------

Video Optimizations

Audio Track Removal: For muted or background videos, removing the audio track reduces file size and bandwidth


Video Poster Images: Use a poster attribute to show an image placeholder before the video loads, improving perceived performance, though it adds some extra request overhead

Adaptive Streaming / Multi-Resolution Sources: Serve multiple resolutions and use player libraries (like VideoJS or streaming protocols like HLS) that auto-select streams based on connection speed, user device, or player size

Automatic Quality and Format Tuning: Platforms like Cloudinaryâ€™s React SDK automatically optimize video format and quality on the fly, delivering the best balance of size and visual fidelity

Lazy Loading Videos: Load video content only when near the viewport, reducing initial page load times and bandwidth,.

Use of CDNs: Deliver video assets via Content Delivery Networks to reduce latency and improve download speeds globally