https://chatgpt.com/c/68239255-0e3c-800c-9326-148b2ab59595


In React Native, error handling is crucial for maintaining app stability and providing a good user experience. Here are different ways to handle errors in a React Native app:

1. Try-Catch Blocks (Synchronous and Async)
Used for catching errors in synchronous code and async/await blocks.

js
Copy
Edit
try {
  const response = await fetchData();
} catch (error) {
  console.error('Error fetching data:', error);
}
2. Global Error Handling
a. ErrorBoundary (for UI Errors - React Component Tree)
Use componentDidCatch and getDerivedStateFromError for class components.

jsx
Copy
Edit
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    // Log error to monitoring service
    console.log('Error:', error);
  }

  render() {
    if (this.state.hasError) {
      return <Text>Something went wrong.</Text>;
    }

    return this.props.children;
  }
}
Use it like:

jsx
Copy
Edit
<ErrorBoundary>
  <YourComponent />
</ErrorBoundary>
b. Global JS Errors
You can capture uncaught JS errors globally using:

js
Copy
Edit
import { ErrorUtils } from 'react-native';

ErrorUtils.setGlobalHandler((error, isFatal) => {
  // Log or show UI
  console.log('Global Error Handler:', error);
});
c. Unhandled Promise Rejections
Some platforms may allow you to catch these:

js
Copy
Edit
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection:', reason);
});
Note: This might work better in Node but isn't universally supported in RN.

3. Third-Party Tools
For monitoring and error tracking in production:

Sentry

Bugsnag

Firebase Crashlytics

These tools allow:

Capturing uncaught exceptions

Logging handled exceptions

User context & app state tracking

4. Network Error Handling
Using axios or fetch, handle network-specific errors.

js
Copy
Edit
axios.get(url).catch(error => {
  if (error.response) {
    // Server responded with a status code not in 2xx
  } else if (error.request) {
    // No response received
  } else {
    // Other error
  }
});
5. UI Feedback on Error
Show user-friendly messages:

Toasts (e.g., react-native-toast-message)

Snackbars (e.g., react-native-paper)

Alert dialogs (Alert.alert)

6. Safe Navigation
Use optional chaining and fallback values to avoid crashes due to null/undefined.

js
Copy
Edit
const name = user?.profile?.name ?? 'Guest';
7. Validation Errors
Use form libraries like:

Formik + Yup

react-hook-form

They help manage and display input validation errors cleanly.





âœ… Step-by-Step: Error Boundary with Functional Components
1. Create an Error Boundary Class Component
React still requires class components for componentDidCatch.

jsx
Copy
Edit
// ErrorBoundary.js
import React from 'react';
import { View, Text } from 'react-native';

export class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, info) {
    // You can also log error to an error reporting service
    console.log('ErrorBoundary caught:', error, info);
  }

  render() {
    if (this.state.hasError) {
      return (
        <View style={{ padding: 20 }}>
          <Text style={{ color: 'red', fontWeight: 'bold' }}>
            Something went wrong!
          </Text>
        </View>
      );
    }

    return this.props.children;
  }
}
2. Use a Custom Hook to Throw Errors in Functional Components
js
Copy
Edit
// useError.js
import { useEffect } from 'react';

export function useErrorThrower(error) {
  useEffect(() => {
    if (error) throw error;
  }, [error]);
}
3. Use It in Your Functional Component
jsx
Copy
Edit
// BuggyComponent.js
import React, { useState } from 'react';
import { Button, Text, View } from 'react-native';
import { useErrorThrower } from './useError';

export function BuggyComponent() {
  const [error, setError] = useState(null);

  useErrorThrower(error); // Will throw inside boundary

  return (
    <View style={{ padding: 20 }}>
      <Text>Click the button to simulate an error.</Text>
      <Button title="Cause Error" onPress={() => setError(new Error('Oops!'))} />
    </View>
  );
}
4. Wrap It in Your App
jsx
Copy
Edit
// App.js
import React from 'react';
import { ErrorBoundary } from './ErrorBoundary';
import { BuggyComponent } from './BuggyComponent';

export default function App() {
  return (
    <ErrorBoundary>
      <BuggyComponent />
    </ErrorBoundary>
  );
}
This setup lets you:

Use functional components normally.

Still leverage a robust error boundary via a class.

Dynamically throw errors via hooks when needed.